input {
  beats {
    port => 5044
  }
}

filter {
  #
  # Parse only nginx access logs:
  # If you have filebeat fields like [fileset][module] == "nginx" or [event][dataset] == "nginx.access",
  # we can narrow it further. This version parses whenever message matches the pattern.
  #

  grok {
    match => {
      "message" => '%{IPORHOST:client_ip} %{DATA:ident} %{DATA:auth} \[%{HTTPDATE:nginx_time}\] "%{WORD:method} %{URIPATHPARAM:request} HTTP/%{NUMBER:http_version}" %{NUMBER:status} %{NUMBER:bytes} "%{DATA:referrer}" "%{DATA:user_agent}" "%{DATA:x_forwarded_for}"'
    }
    tag_on_failure => ["_grok_nginx_access_fail"]
  }

  if "_grok_nginx_access_fail" not in [tags] {

    date {
      match => ["nginx_time", "dd/MMM/yyyy:HH:mm:ss Z"]
      target => "@timestamp"
      remove_field => ["nginx_time"]
    }

    mutate {
      convert => {
        "status" => "integer"
        "bytes"  => "integer"
      }
    }

    useragent {
      source => "user_agent"
      target => "ua"
    }

    # Optional cleanup: turn "-" into empty
    mutate {
      gsub => [
        "referrer", "^-?$", "",
        "x_forwarded_for", "^-?$", "",
        "ident", "^-?$", "",
        "auth", "^-?$", ""
      ]
    }
  }
}

output {
  elasticsearch {
    hosts => ["https://localhost:9200"]
    index => "nginx-access-%{+YYYY.MM.dd}"

    user => "elastic"
    password => "Zp5Fq1P9LfsLJxXljypl"

    # Your plugin requires ssl_enabled (NOT ssl)
    ssl_enabled => true
    ssl_verification_mode => "none"
  }

  # Keep for debugging; remove later
  stdout { codec => rubydebug }
}
